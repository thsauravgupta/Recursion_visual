{"ast":null,"code":"// Advanced execution simulation utilities\nexport class ExecutionSimulator {\n  constructor() {\n    this.executionSteps = [];\n    this.callStack = [];\n    this.nodeId = 1;\n  }\n\n  // Simulate execution of a recursive function\n  simulateExecution(code, params, algorithmName) {\n    try {\n      // Parse function name from code\n      const functionMatch = code.match(/function\\s+(\\w+)/);\n      const functionName = functionMatch ? functionMatch[1] : 'recursiveFunction';\n\n      // Parse parameters\n      const parsedParams = this.parseParameters(params);\n\n      // Generate tree based on algorithm type\n      const treeData = this.generateTreeForAlgorithm(algorithmName, functionName, parsedParams);\n\n      // Generate execution steps\n      const executionSteps = this.generateExecutionSteps(treeData);\n\n      // Calculate statistics\n      const statistics = this.calculateStatistics(treeData);\n      return {\n        treeData,\n        executionSteps,\n        maxDepth: this.calculateMaxDepth(treeData),\n        statistics\n      };\n    } catch (error) {\n      throw new Error(`Execution simulation failed: ${error.message}`);\n    }\n  }\n  parseParameters(paramString) {\n    try {\n      // Handle different parameter formats\n      if (paramString.includes('[')) {\n        // Array parameter\n        return eval(`[${paramString}]`);\n      } else if (paramString.includes(',')) {\n        // Multiple parameters\n        return paramString.split(',').map(p => {\n          const trimmed = p.trim();\n          return isNaN(trimmed) ? trimmed : parseInt(trimmed);\n        });\n      } else {\n        // Single parameter\n        const num = parseInt(paramString.trim());\n        return isNaN(num) ? [paramString.trim()] : [num];\n      }\n    } catch (error) {\n      throw new Error('Invalid parameter format');\n    }\n  }\n  generateTreeForAlgorithm(algorithmName, functionName, params) {\n    switch (algorithmName.toLowerCase()) {\n      case 'fibonacci':\n        return this.generateFibonacciTree(functionName, params[0]);\n      case 'factorial':\n        return this.generateFactorialTree(functionName, params[0]);\n      case 'binary search':\n        return this.generateBinarySearchTree(functionName, params);\n      case 'power function':\n        return this.generatePowerTree(functionName, params[0], params[1]);\n      case 'gcd (euclidean)':\n        return this.generateGCDTree(functionName, params[0], params[1]);\n      case 'sum array':\n        return this.generateSumArrayTree(functionName, params[0]);\n      default:\n        return this.generateGenericTree(functionName, params);\n    }\n  }\n  generateFibonacciTree(functionName, n, x = 400, y = 50) {\n    if (n <= 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [n],\n        result: n,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    const node = {\n      id: this.nodeId++,\n      name: functionName,\n      args: [n],\n      result: null,\n      x,\n      y,\n      state: 'completed',\n      children: []\n    };\n\n    // Generate children\n    const leftChild = this.generateFibonacciTree(functionName, n - 1, x - 100, y + 100);\n    const rightChild = this.generateFibonacciTree(functionName, n - 2, x + 100, y + 100);\n    node.children = [leftChild, rightChild];\n    node.result = leftChild.result + rightChild.result;\n    return node;\n  }\n  generateFactorialTree(functionName, n, x = 400, y = 50) {\n    if (n <= 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [n],\n        result: 1,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    const child = this.generateFactorialTree(functionName, n - 1, x, y + 100);\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [n],\n      result: n * child.result,\n      x,\n      y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n  generateBinarySearchTree(functionName, params) {\n    const [arr, target] = params;\n    return this.binarySearchRecursive(functionName, arr, target, 0, arr.length - 1, 400, 50);\n  }\n  binarySearchRecursive(functionName, arr, target, left, right, x, y) {\n    if (left > right) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, target, left, right],\n        result: -1,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, target, left, right],\n        result: mid,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    let child;\n    if (arr[mid] > target) {\n      child = this.binarySearchRecursive(functionName, arr, target, left, mid - 1, x - 100, y + 100);\n    } else {\n      child = this.binarySearchRecursive(functionName, arr, target, mid + 1, right, x + 100, y + 100);\n    }\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [arr, target, left, right],\n      result: child.result,\n      x,\n      y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n  generatePowerTree(functionName, base, exp, x = 400, y = 50) {\n    if (exp === 0) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: 1,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    if (exp === 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: base,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    if (exp % 2 === 0) {\n      const halfChild = this.generatePowerTree(functionName, base, exp / 2, x, y + 100);\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: halfChild.result * halfChild.result,\n        x,\n        y,\n        state: 'completed',\n        children: [halfChild]\n      };\n    } else {\n      const child = this.generatePowerTree(functionName, base, exp - 1, x, y + 100);\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: base * child.result,\n        x,\n        y,\n        state: 'completed',\n        children: [child]\n      };\n    }\n  }\n  generateGCDTree(functionName, a, b, x = 400, y = 50) {\n    if (b === 0) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [a, b],\n        result: a,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    const child = this.generateGCDTree(functionName, b, a % b, x, y + 100);\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [a, b],\n      result: child.result,\n      x,\n      y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n  generateSumArrayTree(functionName, arr, index = 0, x = 400, y = 50) {\n    if (index >= arr.length) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, index],\n        result: 0,\n        x,\n        y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n    const child = this.generateSumArrayTree(functionName, arr, index + 1, x, y + 100);\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [arr, index],\n      result: arr[index] + child.result,\n      x,\n      y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n  generateGenericTree(functionName, params) {\n    // Simple tree for unknown algorithms\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: params,\n      result: 'result',\n      x: 400,\n      y: 50,\n      state: 'completed',\n      children: []\n    };\n  }\n  generateExecutionSteps(treeData) {\n    const steps = [];\n    const nodes = this.getAllNodesInOrder(treeData);\n    nodes.forEach((node, index) => {\n      steps.push({\n        step: index,\n        activeNode: node.id,\n        callStack: this.generateCallStackForStep(node, index),\n        description: `Calling ${node.name}(${node.args.join(', ')})`\n      });\n    });\n    return steps;\n  }\n  getAllNodesInOrder(node, result = []) {\n    result.push(node);\n    if (node.children) {\n      node.children.forEach(child => this.getAllNodesInOrder(child, result));\n    }\n    return result;\n  }\n  generateCallStackForStep(node, depth) {\n    const stack = [];\n    for (let i = depth; i >= 0; i--) {\n      stack.push(`${node.name}(${node.args.join(', ')})`);\n    }\n    return stack;\n  }\n  calculateMaxDepth(node, depth = 0) {\n    if (!node.children || node.children.length === 0) {\n      return depth;\n    }\n    return Math.max(...node.children.map(child => this.calculateMaxDepth(child, depth + 1)));\n  }\n  calculateStatistics(treeData) {\n    const totalCalls = this.countNodes(treeData);\n    const baseCaseCalls = this.countBaseCases(treeData);\n    const executionTime = Math.floor(Math.random() * 100) + 10; // Simulated\n\n    return {\n      totalCalls,\n      baseCaseCalls,\n      executionTime\n    };\n  }\n  countNodes(node) {\n    if (!node.children || node.children.length === 0) {\n      return 1;\n    }\n    return 1 + node.children.reduce((sum, child) => sum + this.countNodes(child), 0);\n  }\n  countBaseCases(node) {\n    if (!node.children || node.children.length === 0) {\n      return 1;\n    }\n    return node.children.reduce((sum, child) => sum + this.countBaseCases(child), 0);\n  }\n}\nexport const executionSimulator = new ExecutionSimulator();","map":{"version":3,"names":["ExecutionSimulator","constructor","executionSteps","callStack","nodeId","simulateExecution","code","params","algorithmName","functionMatch","match","functionName","parsedParams","parseParameters","treeData","generateTreeForAlgorithm","generateExecutionSteps","statistics","calculateStatistics","maxDepth","calculateMaxDepth","error","Error","message","paramString","includes","eval","split","map","p","trimmed","trim","isNaN","parseInt","num","toLowerCase","generateFibonacciTree","generateFactorialTree","generateBinarySearchTree","generatePowerTree","generateGCDTree","generateSumArrayTree","generateGenericTree","n","x","y","id","name","args","result","state","children","node","leftChild","rightChild","child","arr","target","binarySearchRecursive","length","left","right","mid","Math","floor","base","exp","halfChild","a","b","index","steps","nodes","getAllNodesInOrder","forEach","push","step","activeNode","generateCallStackForStep","description","join","depth","stack","i","max","totalCalls","countNodes","baseCaseCalls","countBaseCases","executionTime","random","reduce","sum","executionSimulator"],"sources":["D:/Projects/git/main_vercel/Recursion_visual/frontend1/src/utils/executionSimulator.js"],"sourcesContent":["// Advanced execution simulation utilities\nexport class ExecutionSimulator {\n  constructor() {\n    this.executionSteps = [];\n    this.callStack = [];\n    this.nodeId = 1;\n  }\n\n  // Simulate execution of a recursive function\n  simulateExecution(code, params, algorithmName) {\n    try {\n      // Parse function name from code\n      const functionMatch = code.match(/function\\s+(\\w+)/);\n      const functionName = functionMatch ? functionMatch[1] : 'recursiveFunction';\n\n      // Parse parameters\n      const parsedParams = this.parseParameters(params);\n\n      // Generate tree based on algorithm type\n      const treeData = this.generateTreeForAlgorithm(algorithmName, functionName, parsedParams);\n\n      // Generate execution steps\n      const executionSteps = this.generateExecutionSteps(treeData);\n\n      // Calculate statistics\n      const statistics = this.calculateStatistics(treeData);\n\n      return {\n        treeData,\n        executionSteps,\n        maxDepth: this.calculateMaxDepth(treeData),\n        statistics\n      };\n    } catch (error) {\n      throw new Error(`Execution simulation failed: ${error.message}`);\n    }\n  }\n\n  parseParameters(paramString) {\n    try {\n      // Handle different parameter formats\n      if (paramString.includes('[')) {\n        // Array parameter\n        return eval(`[${paramString}]`);\n      } else if (paramString.includes(',')) {\n        // Multiple parameters\n        return paramString.split(',').map(p => {\n          const trimmed = p.trim();\n          return isNaN(trimmed) ? trimmed : parseInt(trimmed);\n        });\n      } else {\n        // Single parameter\n        const num = parseInt(paramString.trim());\n        return isNaN(num) ? [paramString.trim()] : [num];\n      }\n    } catch (error) {\n      throw new Error('Invalid parameter format');\n    }\n  }\n\n  generateTreeForAlgorithm(algorithmName, functionName, params) {\n    switch (algorithmName.toLowerCase()) {\n      case 'fibonacci':\n        return this.generateFibonacciTree(functionName, params[0]);\n      case 'factorial':\n        return this.generateFactorialTree(functionName, params[0]);\n      case 'binary search':\n        return this.generateBinarySearchTree(functionName, params);\n      case 'power function':\n        return this.generatePowerTree(functionName, params[0], params[1]);\n      case 'gcd (euclidean)':\n        return this.generateGCDTree(functionName, params[0], params[1]);\n      case 'sum array':\n        return this.generateSumArrayTree(functionName, params[0]);\n      default:\n        return this.generateGenericTree(functionName, params);\n    }\n  }\n\n  generateFibonacciTree(functionName, n, x = 400, y = 50) {\n    if (n <= 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [n],\n        result: n,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const node = {\n      id: this.nodeId++,\n      name: functionName,\n      args: [n],\n      result: null,\n      x, y,\n      state: 'completed',\n      children: []\n    };\n\n    // Generate children\n    const leftChild = this.generateFibonacciTree(functionName, n - 1, x - 100, y + 100);\n    const rightChild = this.generateFibonacciTree(functionName, n - 2, x + 100, y + 100);\n\n    node.children = [leftChild, rightChild];\n    node.result = leftChild.result + rightChild.result;\n\n    return node;\n  }\n\n  generateFactorialTree(functionName, n, x = 400, y = 50) {\n    if (n <= 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [n],\n        result: 1,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const child = this.generateFactorialTree(functionName, n - 1, x, y + 100);\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [n],\n      result: n * child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generateBinarySearchTree(functionName, params) {\n    const [arr, target] = params;\n    return this.binarySearchRecursive(functionName, arr, target, 0, arr.length - 1, 400, 50);\n  }\n\n  binarySearchRecursive(functionName, arr, target, left, right, x, y) {\n    if (left > right) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, target, left, right],\n        result: -1,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] === target) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, target, left, right],\n        result: mid,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    let child;\n    if (arr[mid] > target) {\n      child = this.binarySearchRecursive(functionName, arr, target, left, mid - 1, x - 100, y + 100);\n    } else {\n      child = this.binarySearchRecursive(functionName, arr, target, mid + 1, right, x + 100, y + 100);\n    }\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [arr, target, left, right],\n      result: child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generatePowerTree(functionName, base, exp, x = 400, y = 50) {\n    if (exp === 0) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: 1,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    if (exp === 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: base,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    if (exp % 2 === 0) {\n      const halfChild = this.generatePowerTree(functionName, base, exp / 2, x, y + 100);\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: halfChild.result * halfChild.result,\n        x, y,\n        state: 'completed',\n        children: [halfChild]\n      };\n    } else {\n      const child = this.generatePowerTree(functionName, base, exp - 1, x, y + 100);\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: base * child.result,\n        x, y,\n        state: 'completed',\n        children: [child]\n      };\n    }\n  }\n\n  generateGCDTree(functionName, a, b, x = 400, y = 50) {\n    if (b === 0) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [a, b],\n        result: a,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const child = this.generateGCDTree(functionName, b, a % b, x, y + 100);\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [a, b],\n      result: child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generateSumArrayTree(functionName, arr, index = 0, x = 400, y = 50) {\n    if (index >= arr.length) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, index],\n        result: 0,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const child = this.generateSumArrayTree(functionName, arr, index + 1, x, y + 100);\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [arr, index],\n      result: arr[index] + child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generateGenericTree(functionName, params) {\n    // Simple tree for unknown algorithms\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: params,\n      result: 'result',\n      x: 400,\n      y: 50,\n      state: 'completed',\n      children: []\n    };\n  }\n\n  generateExecutionSteps(treeData) {\n    const steps = [];\n    const nodes = this.getAllNodesInOrder(treeData);\n\n    nodes.forEach((node, index) => {\n      steps.push({\n        step: index,\n        activeNode: node.id,\n        callStack: this.generateCallStackForStep(node, index),\n        description: `Calling ${node.name}(${node.args.join(', ')})`\n      });\n    });\n\n    return steps;\n  }\n\n  getAllNodesInOrder(node, result = []) {\n    result.push(node);\n    if (node.children) {\n      node.children.forEach(child => this.getAllNodesInOrder(child, result));\n    }\n    return result;\n  }\n\n  generateCallStackForStep(node, depth) {\n    const stack = [];\n    for (let i = depth; i >= 0; i--) {\n      stack.push(`${node.name}(${node.args.join(', ')})`);\n    }\n    return stack;\n  }\n\n  calculateMaxDepth(node, depth = 0) {\n    if (!node.children || node.children.length === 0) {\n      return depth;\n    }\n    return Math.max(...node.children.map(child => this.calculateMaxDepth(child, depth + 1)));\n  }\n\n  calculateStatistics(treeData) {\n    const totalCalls = this.countNodes(treeData);\n    const baseCaseCalls = this.countBaseCases(treeData);\n    const executionTime = Math.floor(Math.random() * 100) + 10; // Simulated\n\n    return {\n      totalCalls,\n      baseCaseCalls,\n      executionTime\n    };\n  }\n\n  countNodes(node) {\n    if (!node.children || node.children.length === 0) {\n      return 1;\n    }\n    return 1 + node.children.reduce((sum, child) => sum + this.countNodes(child), 0);\n  }\n\n  countBaseCases(node) {\n    if (!node.children || node.children.length === 0) {\n      return 1;\n    }\n    return node.children.reduce((sum, child) => sum + this.countBaseCases(child), 0);\n  }\n}\n\nexport const executionSimulator = new ExecutionSimulator();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}