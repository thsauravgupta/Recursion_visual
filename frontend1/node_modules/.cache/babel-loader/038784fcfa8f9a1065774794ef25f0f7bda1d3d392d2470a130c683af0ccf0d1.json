{"ast":null,"code":"// Advanced execution simulation utilities\nexport class ExecutionSimulator{constructor(){this.executionSteps=[];this.callStack=[];this.nodeId=1;}// Simulate execution of a recursive function\nsimulateExecution(code,params,algorithmName){try{// Parse function name from code\nconst functionMatch=code.match(/function\\s+(\\w+)/);const functionName=functionMatch?functionMatch[1]:'recursiveFunction';// Parse parameters\nconst parsedParams=this.parseParameters(params);// Generate tree based on algorithm type\nconst treeData=this.generateTreeForAlgorithm(algorithmName,functionName,parsedParams);// Generate execution steps\nconst executionSteps=this.generateExecutionSteps(treeData);// Calculate statistics\nconst statistics=this.calculateStatistics(treeData);return{treeData,executionSteps,maxDepth:this.calculateMaxDepth(treeData),statistics};}catch(error){throw new Error(\"Execution simulation failed: \".concat(error.message));}}parseParameters(paramString){try{// Handle different parameter formats\nif(paramString.includes('[')){// Array parameter\nreturn eval(\"[\".concat(paramString,\"]\"));}else if(paramString.includes(',')){// Multiple parameters\nreturn paramString.split(',').map(p=>{const trimmed=p.trim();return isNaN(trimmed)?trimmed:parseInt(trimmed);});}else{// Single parameter\nconst num=parseInt(paramString.trim());return isNaN(num)?[paramString.trim()]:[num];}}catch(error){throw new Error('Invalid parameter format');}}generateTreeForAlgorithm(algorithmName,functionName,params){switch(algorithmName.toLowerCase()){case'fibonacci':return this.generateFibonacciTree(functionName,params[0]);case'factorial':return this.generateFactorialTree(functionName,params[0]);case'binary search':return this.generateBinarySearchTree(functionName,params);case'power function':return this.generatePowerTree(functionName,params[0],params[1]);case'gcd (euclidean)':return this.generateGCDTree(functionName,params[0],params[1]);case'sum array':return this.generateSumArrayTree(functionName,params[0]);default:return this.generateGenericTree(functionName,params);}}generateFibonacciTree(functionName,n){let x=arguments.length>2&&arguments[2]!==undefined?arguments[2]:400;let y=arguments.length>3&&arguments[3]!==undefined?arguments[3]:50;if(n<=1){return{id:this.nodeId++,name:functionName,args:[n],result:n,x,y,state:'baseCase',children:[]};}const node={id:this.nodeId++,name:functionName,args:[n],result:null,x,y,state:'completed',children:[]};// Generate children\nconst leftChild=this.generateFibonacciTree(functionName,n-1,x-100,y+100);const rightChild=this.generateFibonacciTree(functionName,n-2,x+100,y+100);node.children=[leftChild,rightChild];node.result=leftChild.result+rightChild.result;return node;}generateFactorialTree(functionName,n){let x=arguments.length>2&&arguments[2]!==undefined?arguments[2]:400;let y=arguments.length>3&&arguments[3]!==undefined?arguments[3]:50;if(n<=1){return{id:this.nodeId++,name:functionName,args:[n],result:1,x,y,state:'baseCase',children:[]};}const child=this.generateFactorialTree(functionName,n-1,x,y+100);return{id:this.nodeId++,name:functionName,args:[n],result:n*child.result,x,y,state:'completed',children:[child]};}generateBinarySearchTree(functionName,params){const[arr,target]=params;return this.binarySearchRecursive(functionName,arr,target,0,arr.length-1,400,50);}binarySearchRecursive(functionName,arr,target,left,right,x,y){if(left>right){return{id:this.nodeId++,name:functionName,args:[arr,target,left,right],result:-1,x,y,state:'baseCase',children:[]};}const mid=Math.floor((left+right)/2);if(arr[mid]===target){return{id:this.nodeId++,name:functionName,args:[arr,target,left,right],result:mid,x,y,state:'baseCase',children:[]};}let child;if(arr[mid]>target){child=this.binarySearchRecursive(functionName,arr,target,left,mid-1,x-100,y+100);}else{child=this.binarySearchRecursive(functionName,arr,target,mid+1,right,x+100,y+100);}return{id:this.nodeId++,name:functionName,args:[arr,target,left,right],result:child.result,x,y,state:'completed',children:[child]};}generatePowerTree(functionName,base,exp){let x=arguments.length>3&&arguments[3]!==undefined?arguments[3]:400;let y=arguments.length>4&&arguments[4]!==undefined?arguments[4]:50;if(exp===0){return{id:this.nodeId++,name:functionName,args:[base,exp],result:1,x,y,state:'baseCase',children:[]};}if(exp===1){return{id:this.nodeId++,name:functionName,args:[base,exp],result:base,x,y,state:'baseCase',children:[]};}if(exp%2===0){const halfChild=this.generatePowerTree(functionName,base,exp/2,x,y+100);return{id:this.nodeId++,name:functionName,args:[base,exp],result:halfChild.result*halfChild.result,x,y,state:'completed',children:[halfChild]};}else{const child=this.generatePowerTree(functionName,base,exp-1,x,y+100);return{id:this.nodeId++,name:functionName,args:[base,exp],result:base*child.result,x,y,state:'completed',children:[child]};}}generateGCDTree(functionName,a,b){let x=arguments.length>3&&arguments[3]!==undefined?arguments[3]:400;let y=arguments.length>4&&arguments[4]!==undefined?arguments[4]:50;if(b===0){return{id:this.nodeId++,name:functionName,args:[a,b],result:a,x,y,state:'baseCase',children:[]};}const child=this.generateGCDTree(functionName,b,a%b,x,y+100);return{id:this.nodeId++,name:functionName,args:[a,b],result:child.result,x,y,state:'completed',children:[child]};}generateSumArrayTree(functionName,arr){let index=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let x=arguments.length>3&&arguments[3]!==undefined?arguments[3]:400;let y=arguments.length>4&&arguments[4]!==undefined?arguments[4]:50;if(index>=arr.length){return{id:this.nodeId++,name:functionName,args:[arr,index],result:0,x,y,state:'baseCase',children:[]};}const child=this.generateSumArrayTree(functionName,arr,index+1,x,y+100);return{id:this.nodeId++,name:functionName,args:[arr,index],result:arr[index]+child.result,x,y,state:'completed',children:[child]};}generateGenericTree(functionName,params){// Simple tree for unknown algorithms\nreturn{id:this.nodeId++,name:functionName,args:params,result:'result',x:400,y:50,state:'completed',children:[]};}generateExecutionSteps(treeData){const steps=[];const nodes=this.getAllNodesInOrder(treeData);nodes.forEach((node,index)=>{steps.push({step:index,activeNode:node.id,callStack:this.generateCallStackForStep(node,index),description:\"Calling \".concat(node.name,\"(\").concat(node.args.join(', '),\")\")});});return steps;}getAllNodesInOrder(node){let result=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];result.push(node);if(node.children){node.children.forEach(child=>this.getAllNodesInOrder(child,result));}return result;}generateCallStackForStep(node,depth){const stack=[];for(let i=depth;i>=0;i--){stack.push(\"\".concat(node.name,\"(\").concat(node.args.join(', '),\")\"));}return stack;}calculateMaxDepth(node){let depth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(!node.children||node.children.length===0){return depth;}return Math.max(...node.children.map(child=>this.calculateMaxDepth(child,depth+1)));}calculateStatistics(treeData){const totalCalls=this.countNodes(treeData);const baseCaseCalls=this.countBaseCases(treeData);const executionTime=Math.floor(Math.random()*100)+10;// Simulated\nreturn{totalCalls,baseCaseCalls,executionTime};}countNodes(node){if(!node.children||node.children.length===0){return 1;}return 1+node.children.reduce((sum,child)=>sum+this.countNodes(child),0);}countBaseCases(node){if(!node.children||node.children.length===0){return 1;}return node.children.reduce((sum,child)=>sum+this.countBaseCases(child),0);}}export const executionSimulator=new ExecutionSimulator();","map":{"version":3,"names":["ExecutionSimulator","constructor","executionSteps","callStack","nodeId","simulateExecution","code","params","algorithmName","functionMatch","match","functionName","parsedParams","parseParameters","treeData","generateTreeForAlgorithm","generateExecutionSteps","statistics","calculateStatistics","maxDepth","calculateMaxDepth","error","Error","concat","message","paramString","includes","eval","split","map","p","trimmed","trim","isNaN","parseInt","num","toLowerCase","generateFibonacciTree","generateFactorialTree","generateBinarySearchTree","generatePowerTree","generateGCDTree","generateSumArrayTree","generateGenericTree","n","x","arguments","length","undefined","y","id","name","args","result","state","children","node","leftChild","rightChild","child","arr","target","binarySearchRecursive","left","right","mid","Math","floor","base","exp","halfChild","a","b","index","steps","nodes","getAllNodesInOrder","forEach","push","step","activeNode","generateCallStackForStep","description","join","depth","stack","i","max","totalCalls","countNodes","baseCaseCalls","countBaseCases","executionTime","random","reduce","sum","executionSimulator"],"sources":["D:/Projects/git/main_vercel/Recursion_visual/frontend1/src/utils/executionSimulator.js"],"sourcesContent":["// Advanced execution simulation utilities\nexport class ExecutionSimulator {\n  constructor() {\n    this.executionSteps = [];\n    this.callStack = [];\n    this.nodeId = 1;\n  }\n\n  // Simulate execution of a recursive function\n  simulateExecution(code, params, algorithmName) {\n    try {\n      // Parse function name from code\n      const functionMatch = code.match(/function\\s+(\\w+)/);\n      const functionName = functionMatch ? functionMatch[1] : 'recursiveFunction';\n\n      // Parse parameters\n      const parsedParams = this.parseParameters(params);\n\n      // Generate tree based on algorithm type\n      const treeData = this.generateTreeForAlgorithm(algorithmName, functionName, parsedParams);\n\n      // Generate execution steps\n      const executionSteps = this.generateExecutionSteps(treeData);\n\n      // Calculate statistics\n      const statistics = this.calculateStatistics(treeData);\n\n      return {\n        treeData,\n        executionSteps,\n        maxDepth: this.calculateMaxDepth(treeData),\n        statistics\n      };\n    } catch (error) {\n      throw new Error(`Execution simulation failed: ${error.message}`);\n    }\n  }\n\n  parseParameters(paramString) {\n    try {\n      // Handle different parameter formats\n      if (paramString.includes('[')) {\n        // Array parameter\n        return eval(`[${paramString}]`);\n      } else if (paramString.includes(',')) {\n        // Multiple parameters\n        return paramString.split(',').map(p => {\n          const trimmed = p.trim();\n          return isNaN(trimmed) ? trimmed : parseInt(trimmed);\n        });\n      } else {\n        // Single parameter\n        const num = parseInt(paramString.trim());\n        return isNaN(num) ? [paramString.trim()] : [num];\n      }\n    } catch (error) {\n      throw new Error('Invalid parameter format');\n    }\n  }\n\n  generateTreeForAlgorithm(algorithmName, functionName, params) {\n    switch (algorithmName.toLowerCase()) {\n      case 'fibonacci':\n        return this.generateFibonacciTree(functionName, params[0]);\n      case 'factorial':\n        return this.generateFactorialTree(functionName, params[0]);\n      case 'binary search':\n        return this.generateBinarySearchTree(functionName, params);\n      case 'power function':\n        return this.generatePowerTree(functionName, params[0], params[1]);\n      case 'gcd (euclidean)':\n        return this.generateGCDTree(functionName, params[0], params[1]);\n      case 'sum array':\n        return this.generateSumArrayTree(functionName, params[0]);\n      default:\n        return this.generateGenericTree(functionName, params);\n    }\n  }\n\n  generateFibonacciTree(functionName, n, x = 400, y = 50) {\n    if (n <= 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [n],\n        result: n,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const node = {\n      id: this.nodeId++,\n      name: functionName,\n      args: [n],\n      result: null,\n      x, y,\n      state: 'completed',\n      children: []\n    };\n\n    // Generate children\n    const leftChild = this.generateFibonacciTree(functionName, n - 1, x - 100, y + 100);\n    const rightChild = this.generateFibonacciTree(functionName, n - 2, x + 100, y + 100);\n\n    node.children = [leftChild, rightChild];\n    node.result = leftChild.result + rightChild.result;\n\n    return node;\n  }\n\n  generateFactorialTree(functionName, n, x = 400, y = 50) {\n    if (n <= 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [n],\n        result: 1,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const child = this.generateFactorialTree(functionName, n - 1, x, y + 100);\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [n],\n      result: n * child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generateBinarySearchTree(functionName, params) {\n    const [arr, target] = params;\n    return this.binarySearchRecursive(functionName, arr, target, 0, arr.length - 1, 400, 50);\n  }\n\n  binarySearchRecursive(functionName, arr, target, left, right, x, y) {\n    if (left > right) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, target, left, right],\n        result: -1,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] === target) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, target, left, right],\n        result: mid,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    let child;\n    if (arr[mid] > target) {\n      child = this.binarySearchRecursive(functionName, arr, target, left, mid - 1, x - 100, y + 100);\n    } else {\n      child = this.binarySearchRecursive(functionName, arr, target, mid + 1, right, x + 100, y + 100);\n    }\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [arr, target, left, right],\n      result: child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generatePowerTree(functionName, base, exp, x = 400, y = 50) {\n    if (exp === 0) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: 1,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    if (exp === 1) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: base,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    if (exp % 2 === 0) {\n      const halfChild = this.generatePowerTree(functionName, base, exp / 2, x, y + 100);\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: halfChild.result * halfChild.result,\n        x, y,\n        state: 'completed',\n        children: [halfChild]\n      };\n    } else {\n      const child = this.generatePowerTree(functionName, base, exp - 1, x, y + 100);\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [base, exp],\n        result: base * child.result,\n        x, y,\n        state: 'completed',\n        children: [child]\n      };\n    }\n  }\n\n  generateGCDTree(functionName, a, b, x = 400, y = 50) {\n    if (b === 0) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [a, b],\n        result: a,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const child = this.generateGCDTree(functionName, b, a % b, x, y + 100);\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [a, b],\n      result: child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generateSumArrayTree(functionName, arr, index = 0, x = 400, y = 50) {\n    if (index >= arr.length) {\n      return {\n        id: this.nodeId++,\n        name: functionName,\n        args: [arr, index],\n        result: 0,\n        x, y,\n        state: 'baseCase',\n        children: []\n      };\n    }\n\n    const child = this.generateSumArrayTree(functionName, arr, index + 1, x, y + 100);\n\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: [arr, index],\n      result: arr[index] + child.result,\n      x, y,\n      state: 'completed',\n      children: [child]\n    };\n  }\n\n  generateGenericTree(functionName, params) {\n    // Simple tree for unknown algorithms\n    return {\n      id: this.nodeId++,\n      name: functionName,\n      args: params,\n      result: 'result',\n      x: 400,\n      y: 50,\n      state: 'completed',\n      children: []\n    };\n  }\n\n  generateExecutionSteps(treeData) {\n    const steps = [];\n    const nodes = this.getAllNodesInOrder(treeData);\n\n    nodes.forEach((node, index) => {\n      steps.push({\n        step: index,\n        activeNode: node.id,\n        callStack: this.generateCallStackForStep(node, index),\n        description: `Calling ${node.name}(${node.args.join(', ')})`\n      });\n    });\n\n    return steps;\n  }\n\n  getAllNodesInOrder(node, result = []) {\n    result.push(node);\n    if (node.children) {\n      node.children.forEach(child => this.getAllNodesInOrder(child, result));\n    }\n    return result;\n  }\n\n  generateCallStackForStep(node, depth) {\n    const stack = [];\n    for (let i = depth; i >= 0; i--) {\n      stack.push(`${node.name}(${node.args.join(', ')})`);\n    }\n    return stack;\n  }\n\n  calculateMaxDepth(node, depth = 0) {\n    if (!node.children || node.children.length === 0) {\n      return depth;\n    }\n    return Math.max(...node.children.map(child => this.calculateMaxDepth(child, depth + 1)));\n  }\n\n  calculateStatistics(treeData) {\n    const totalCalls = this.countNodes(treeData);\n    const baseCaseCalls = this.countBaseCases(treeData);\n    const executionTime = Math.floor(Math.random() * 100) + 10; // Simulated\n\n    return {\n      totalCalls,\n      baseCaseCalls,\n      executionTime\n    };\n  }\n\n  countNodes(node) {\n    if (!node.children || node.children.length === 0) {\n      return 1;\n    }\n    return 1 + node.children.reduce((sum, child) => sum + this.countNodes(child), 0);\n  }\n\n  countBaseCases(node) {\n    if (!node.children || node.children.length === 0) {\n      return 1;\n    }\n    return node.children.reduce((sum, child) => sum + this.countBaseCases(child), 0);\n  }\n}\n\nexport const executionSimulator = new ExecutionSimulator();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}